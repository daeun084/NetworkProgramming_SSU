# NetworkingProgramming_SSU_Week7
## Generating Certificates

1. Human-generated
2. Machine-generated

RSA key

- for puk
- stored at the server

### Pem

privacy enhanced mail

- contain pr, pu
- using the key, make pem
- make request for certificate
- stored at the server
- concatenated certificate containers
    - **certificate, pr key**

generated by certificate org.

send certificate public key to client

## ⭐️ Certificate Generation

1. install openssl
2. generate configuration file `.cnf`
    
    `openssl.cnf`
    
3. generate private key
    
    `openssl genrsa -out david.key 2048`
    
    generate random key value
    
    0 ~ 2^2048
    
    → generate `david.key`
    
4. generate public key
    
    `openssl sra -in david.key -pubout -out public.key`
    
    → rsa public key out
    
    → generate `public.key`
    
    smaller than private key
    
5. generate CSR certificate signing request
    
    `open ssl req -new -key david.key -out david.csr`
    
    for designing configuration file
    
    `open ssl req -new -key david.key -out david.csr -config openssl.cnf`
    
6. generate CRT certificate
    
    `openssl req -x509 -key david.key -in david.csr -out david.crt`
    

`openssl req -x509 -key david.key -in david.csr -out david.crt - config openssl.cnf`

send it to certificate org and make crt.

<br>

# Python TLS Implementation

python 3.4

### SSL  Module

- OpenSSL lib
    - Lib/ssl.py
    - import ssl
- pyOpenSSL

- `ssl.create_default_context(purpose=Purpose.SERVER_AUTH, cafile=None, capath=None, cadata=None)`
    - purpose
    - cafile : CA file
        - path to a file of CA certificates in PEM format
        - server can make many pem
            - attach a socket and configuration using pem
            - client can use one pem for connecting certif
            - 머라느 ㅋ ㅋ
    - capath
- `ssl.wrap_socket(sock, keyfile=None, certfile=None,
server_side=False, cert_reqs=CERT_NONE,
ssl_version=PROTOCOL_TLS, ca_certs=None,
do_handshake_on_connect=True,
suppress_ragged_eofs=True, ciphers=None)`
    - server_side
        - bool which identifies whether server-side is desired from this socket.
    - cert_reqs
        - specifies whether a certificate from the otherside is required or not
    

### Securing a Socket

- General Approach
    - context - message for object when using the socket
    - `ssl.sock = context.wrap_socket(sock, .. )`
- Client implementation
    1. create context
    2. create socket
    3. connect
    4. create encrypted socket
    5. receive via wrapped socket
- Server implememtation
    1. create ocntext
    2. **load server PEM file**
    3. create socket
    4. listen
    5. accept
    6. create encrypted socket
    7. send via wrapped socket

# Tracing the Message

⭐ IP addr, port# are not encrypted
→ we can see TCP/IP header


# Hand-Picked Cipher & Perfect Forward Security
result for tls handshake

- chosen
- define
- key

cipher algorithm